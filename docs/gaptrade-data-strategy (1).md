# مستندات معماری مدیریت داده GapTrade

## معرفی و هدف

این سند معماری، استراتژی‌های مدیریت داده و به‌روزرسانی اطلاعات در سمت فرانت‌اند پروژه GapTrade را تشریح می‌کند. GapTrade یک سیستم هوشمند کشف آربیتراژ در بازار ارزهای دیجیتال ایران است که دسترسی به داده‌های به‌روز و دقیق، از اصلی‌ترین نیازهای آن محسوب می‌شود.

### اهداف معماری داده

ما در طراحی سیستم مدیریت داده GapTrade چهار هدف اصلی را دنبال می‌کنیم:

1. **پوشش نیازهای متنوع بخش‌های مختلف**: شامل داده‌های عمومی، داده‌های شخصی‌سازی شده، و داده‌های بلادرنگ
2. **پیچیدگی حداقلی**: طراحی API‌های ساده و یکپارچه برای تیم‌های توسعه
3. **تفکیک مسئولیت‌ها**: جداسازی منطق دریافت داده از منطق نمایش
4. **مقیاس‌پذیری**: پشتیبانی از رشد تعداد کاربران بدون افزایش متناسب فشار روی بک‌اند

### چالش‌های خاص GapTrade

GapTrade با سه دسته داده متفاوت سروکار دارد که هر کدام نیازمند استراتژی مدیریت متمایزی هستند:

1. **داده‌های سرد (آپدیت ساعتی)**: مانند فرصت‌های آربیتراژ در صفحه عمومی، که نیاز به به‌روزرسانی هر ساعت دارند
2. **داده‌های گرم (آپدیت دقیقه‌ای)**: مانند قیمت‌های ارز در صرافی‌ها، که باید هر دقیقه به‌روز شوند
3. **داده‌های داغ (بلادرنگ)**: مانند فرصت‌های آربیتراژ برای کاربران مشترک، که باید در لحظه دریافت شوند

همچنین، چون GapTrade به‌عنوان PWA ارائه می‌شود، باید قابلیت کارکرد آفلاین و همگام‌سازی داده را نیز داشته باشد.

## استراتژی‌های مدیریت داده

براساس نیازهای ذکر شده، یک معماری چندلایه با سه استراتژی اصلی برای مدیریت داده طراحی کرده‌ایم:

### 1. لایه‌بندی کش برای داده‌های سرد و گرم

برای داده‌هایی که نیاز به به‌روزرسانی دوره‌ای دارند (مانند فرصت‌های آربیتراژ عمومی و قیمت‌های ارز)، یک ساختار چندلایه‌ای کش استفاده می‌کنیم:

#### کش لایه Edge (CDN)

* **هدف**: کاهش درخواست‌های تکراری به بک‌اند و تسریع زمان پاسخ
* **سازوکار**: استفاده از `cache-control: s-maxage=3600, stale-while-revalidate` برای داده‌های سرد
* **مزیت**: درخواست‌های یک ساعت بسیار کاهش می‌یابد، حتی با وجود کاربران متعدد

#### کش سمت سرور (Server-Side Cache)

* **هدف**: بهینه‌سازی داده‌های گرم با دوره به‌روزرسانی کوتاه‌تر
* **سازوکار**: استفاده از ISR (Incremental Static Regeneration) با TTL 60 ثانیه‌ای
* **مزیت**: داده جدید فقط یک بار در هر دقیقه فچ می‌شود، صرف‌نظر از تعداد کاربران

### 2. ارتباط WebSocket برای داده‌های داغ

برای داده‌هایی که نیاز به دریافت لحظه‌ای دارند (مانند فرصت‌های آربیتراژ شخصی‌سازی شده):

* **هدف**: ارائه به‌روزرسانی‌های فوری بدون درخواست‌های مکرر
* **سازوکار**: اتصال WebSocket به سروری که به Kafka متصل است
* **مدل Topic**: `user_<userId>_arbitrage` برای فرصت‌های آربیتراژ شخصی‌سازی شده
* **مزیت**: دریافت فوری داده بدون نیاز به polling، بدون درخواست‌های اضافی به بک‌اند

### 3. مدیریت حالت با Svelte Stores

* **هدف**: تمرکززدایی مدیریت داده و ارائه یک API یکپارچه به کامپوننت‌ها
* **سازوکار**: استفاده از Svelte Stores به‌عنوان لایه میانی بین منابع داده و کامپوننت‌ها
* **مزیت**: کامپوننت‌ها فقط به داده subscribe می‌شوند، بدون درگیری با جزئیات دریافت داده

### 4. راهکارهای PWA و آفلاین

* **هدف**: حفظ عملکرد اپلیکیشن در شرایط آفلاین یا اتصال ضعیف
* **سازوکار**: ترکیب Service Worker، IndexedDB و استراتژی‌های کش
* **مزیت**: تجربه کاربری بهبود یافته و قابلیت استفاده در شرایط مختلف اتصال

## ساختار پوشه‌بندی

برای پیاده‌سازی این معماری، ساختار پوشه‌بندی زیر پیشنهاد می‌شود:

```
src/
├── app.html               # قالب اصلی SvelteKit
├── routes/                # روت‌های مختلف برنامه
│   ├── +layout.svelte     # لایوت اصلی
│   ├── +page.svelte       # صفحه اصلی
│   └── ...
├── lib/                   # کتابخانه‌های اشتراکی
│   ├── stores/            # Svelte Stores
│   │   ├── index.ts       # صادرات مرکزی تمام store‌ها
│   │   ├── arbitrage.ts   # Store فرصت‌های آربیتراژ
│   │   ├── prices.ts      # Store قیمت‌های ارز
│   │   ├── user.ts        # Store اطلاعات کاربر
│   │   └── settings.ts    # Store تنظیمات
│   │
│   ├── services/          # سرویس‌های ارتباطی
│   │   ├── api.ts         # کلاینت API برای درخواست‌های HTTP
│   │   ├── websocket.ts   # مدیریت اتصالات WebSocket
│   │   ├── cache.ts       # تابع‌های مدیریت کش
│   │   └── offline.ts     # مدیریت حالت آفلاین
│   │
│   ├── adapters/          # آداپتورهای داده
│   │   ├── cold-data.ts   # آداپتور داده‌های سرد (ساعتی)
│   │   ├── warm-data.ts   # آداپتور داده‌های گرم (دقیقه‌ای)
│   │   └── hot-data.ts    # آداپتور داده‌های داغ (لحظه‌ای)
│   │
│   └── utils/             # توابع کمکی
│       ├── date.ts        # توابع کار با تاریخ
│       ├── formatters.ts  # فرمت‌کننده‌های داده
│       └── polling.ts     # توابع کمکی برای polling
│
├── components/            # کامپوننت‌های قابل استفاده مجدد
│   ├── atoms/             # کامپوننت‌های اتمیک
│   ├── molecules/         # کامپوننت‌های مولکولی
│   └── organisms/         # کامپوننت‌های ارگانیسم
│
└── service-worker.js      # پیاده‌سازی Service Worker برای PWA
```

## توضیحات تفصیلی فایل‌ها

### 1. مدیریت Store‌ها (`src/lib/stores/`)

#### `src/lib/stores/index.ts`

این فایل به‌عنوان نقطه دسترسی مرکزی به تمام store‌های برنامه عمل می‌کند و تمامی store‌ها را صادر می‌کند.

```typescript
// نمونه‌ای از محتوای فایل (بدون کد واقعی)
export * from './arbitrage';
export * from './prices';
export * from './user';
export * from './settings';
```

#### `src/lib/stores/arbitrage.ts`

این فایل مدیریت داده‌های مربوط به فرصت‌های آربیتراژ را انجام می‌دهد. باید دو نوع فرصت آربیتراژ را مدیریت کند:

1. فرصت‌های عمومی با تأخیر (داده‌های سرد)
2. فرصت‌های آنی برای کاربران پریمیوم (داده‌های داغ)

نکات مهم:
- برای هر نوع داده، یک store جداگانه تعریف کنید
- از آداپتورهای مربوطه برای دریافت داده استفاده کنید
- مکانیزم‌های مدیریت خطا و loading state را تعبیه کنید

#### `src/lib/stores/prices.ts`

مدیریت قیمت‌های ارزها در صرافی‌های مختلف را انجام می‌دهد. این داده‌ها جزء داده‌های گرم هستند که هر دقیقه به‌روز می‌شوند.

نکات مهم:
- استفاده از TTL یک دقیقه‌ای برای داده‌ها
- پشتیبانی از آپدیت در پس‌زمینه با الگوی Stale-While-Revalidate
- فیلترکردن داده‌ها برای صرافی‌ها یا ارزهای خاص

#### `src/lib/stores/user.ts`

مدیریت اطلاعات کاربر، وضعیت احراز هویت و تنظیمات کاربر را انجام می‌دهد.

نکات مهم:
- ذخیره‌سازی توکن احراز هویت و اطلاعات پروفایل
- مدیریت وضعیت لاگین/لاگ‌اوت
- آپدیت داده‌ها در هنگام تغییر وضعیت کاربر

#### `src/lib/stores/settings.ts`

مدیریت تنظیمات برنامه و ترجیحات کاربر را انجام می‌دهد.

نکات مهم:
- ذخیره‌سازی تنظیمات در localStorage برای استفاده آفلاین
- تعریف تنظیمات پیش‌فرض و امکان ریست
- همگام‌سازی تنظیمات با سرور برای کاربران لاگین‌شده

### 2. سرویس‌های ارتباطی (`src/lib/services/`)

#### `src/lib/services/api.ts`

این فایل یک کلاینت API برای مدیریت درخواست‌های HTTP ارائه می‌دهد.

نکات مهم:
- پیاده‌سازی توابع کمکی برای GET، POST، PUT و دیگر متدهای HTTP
- مدیریت هدرهای استاندارد و توکن‌های احراز هویت
- مدیریت یکپارچه خطاها و تلاش مجدد در صورت شکست

#### `src/lib/services/websocket.ts`

مدیریت ارتباطات WebSocket برای داده‌های بلادرنگ را انجام می‌دهد.

نکات مهم:
- ایجاد و مدیریت اتصال WebSocket
- پیاده‌سازی مکانیزم‌های اتصال مجدد خودکار
- پیاده‌سازی نظام تشخیص وضعیت اتصال (سالم، قطع، در حال اتصال مجدد)
- مدیریت subscriptions به topic‌های مختلف

#### `src/lib/services/cache.ts`

توابع مدیریت کش برای ذخیره و بازیابی داده‌ها.

نکات مهم:
- پیاده‌سازی لایه‌ای شفاف روی IndexedDB
- توابع کمکی برای ذخیره، بازیابی و پاک کردن داده‌ها
- مدیریت TTL برای کش‌های مختلف
- همگام‌سازی بین تب‌ها با استفاده از BroadcastChannel API

#### `src/lib/services/offline.ts`

مدیریت حالت آفلاین برنامه و هماهنگی با Service Worker.

نکات مهم:
- تشخیص وضعیت اتصال به اینترنت
- مدیریت صف درخواست‌های آفلاین
- همگام‌سازی داده‌ها پس از اتصال مجدد
- ارتباط با Service Worker برای مدیریت کش

### 3. آداپتورهای داده (`src/lib/adapters/`)

آداپتورها لایه میانی بین سرویس‌های خام و store‌ها هستند. این لایه مسئول انتخاب استراتژی مناسب دریافت داده، کش‌گیری و پردازش اولیه داده است.

#### `src/lib/adapters/cold-data.ts`

آداپتور برای داده‌های سرد با به‌روزرسانی ساعتی.

نکات مهم:
- استفاده از ISR (Incremental Static Regeneration) برای کش سمت سرور
- استفاده از هدر `Cache-Control` با TTL یک ساعته
- پیاده‌سازی الگوی Stale-While-Revalidate

#### `src/lib/adapters/warm-data.ts`

آداپتور برای داده‌های گرم با به‌روزرسانی دقیقه‌ای.

نکات مهم:
- پیاده‌سازی polling هوشمند با فاصله زمانی یک دقیقه
- مدیریت debounce برای جلوگیری از درخواست‌های همزمان
- تنظیم خودکار فاصله polling بر اساس وضعیت فعالیت صفحه (visible/hidden)

#### `src/lib/adapters/hot-data.ts`

آداپتور برای داده‌های داغ با به‌روزرسانی لحظه‌ای.

نکات مهم:
- اتصال به سرویس WebSocket
- مدیریت topic‌های مختلف برای داده‌های مختلف
- پیاده‌سازی Circuit Breaker برای تغییر به polling در صورت قطعی WebSocket
- ذخیره offset پیام‌ها برای بازپخش در صورت قطعی

### 4. پیاده‌سازی Service Worker (`src/service-worker.js`)

Service Worker نقش مهمی در قابلیت PWA و کارکرد آفلاین برنامه دارد.

نکات مهم:
- استراتژی کش برای انواع مختلف دارایی‌ها (HTML، CSS، JS، تصاویر)
- استراتژی کش برای درخواست‌های API (Network First، Cache First، Stale-While-Revalidate)
- مدیریت درخواست‌های آفلاین (Background Sync)
- توجه به عدم تداخل با استراتژی‌های کش دیگر

```javascript
// نمونه‌ای از استراتژی‌های مختلف کش در Service Worker (بدون کد واقعی)

// برای منابع استاتیک: Cache First
// برای داده‌های API سرد: Stale-While-Revalidate با TTL طولانی
// برای داده‌های API گرم: Network First با فالبک به کش
// برای داده‌های API داغ: Network Only (بدون کش)
```

## ملاحظات تکمیلی

### 1. هماهنگی با SvelteKit

SvelteKit ویژگی‌های مخصوصی برای SSR و لود داده دارد. برای همگام‌سازی با SvelteKit:

- استفاده از `load` function در `+page.js` برای داده‌های اولیه
- استفاده از `+page.server.js` برای لاجیک سمت سرور و SSR
- تعریف `load` با set-cookies, cache و headers مناسب

### 2. بهینه‌سازی پرفورمنس

برای حفظ بهینگی مصرف منابع:

- استفاده از ETag برای پاسخ‌های 304 Not Modified
- فعال‌سازی compression (gzip/brotli) برای پاسخ‌های API
- مدیریت مؤثر Lifecycle کامپوننت‌ها با `onMount` و `onDestroy`
- تغییر هوشمند فاصله polling بر اساس visibility صفحه

### 3. هماهنگی با PWA

برای ارائه تجربه PWA در کنار استراتژی‌های داده:

- استفاده از App Shell Architecture برای لود سریع
- ذخیره کش‌های مختلف در IndexedDB با نام‌گذاری مشخص
- پیاده‌سازی Background Sync برای عملیات متوقف‌شده در حالت آفلاین
- ارائه نسخه آفلاین با محتوای حداقلی برای بخش‌های حیاتی برنامه

### 4. Telemetry و Monitoring

برای پایش عملکرد سیستم و شناسایی مشکلات:

- رهگیری نرخ Hit/Miss کش در لایه‌های مختلف
- اندازه‌گیری latency از Kafka تا DOM Update
- پایش مصرف پهنای باند کاربر
- رهگیری خطاهای WebSocket و استراتژی‌های fallback

## خلاصه و نتیجه‌گیری

معماری داده پیشنهادی برای GapTrade به خوبی چهار هدف اصلی ما را پوشش می‌دهد:

1. **پوشش نیازهای متنوع**: با تفکیک داده‌ها به سه دسته سرد، گرم و داغ و ارائه استراتژی مناسب برای هر یک
2. **پیچیدگی حداقلی**: با پنهان‌سازی جزئیات پیچیده در آداپتورها و ارائه API ساده به کامپوننت‌ها
3. **تفکیک مسئولیت‌ها**: با جداسازی لایه‌های سرویس، آداپتور و store
4. **مقیاس‌پذیری**: با کاهش بار روی بک‌اند از طریق کش چندلایه‌ای و WebSocket

این معماری انعطاف‌پذیری، عملکرد و مقیاس‌پذیری را در یک ساختار منظم ولی غیرپیچیده ترکیب می‌کند و بستر مناسبی برای توسعه دراز مدت GapTrade فراهم می‌آورد.
