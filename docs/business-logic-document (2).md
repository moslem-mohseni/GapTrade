# منطق بیزینسی پروژه GapTrade

## ساختار معماری و منطق کلی پروژه

در پروژه GapTrade، ما از معماری تمیز (Clean Architecture) استفاده می‌کنیم. چرا؟ چون این معماری به ما امکان می‌دهد منطق بیزینسی خود را از جزئیات فنی مثل دیتابیس، وب‌سرویس‌ها و فریم‌ورک‌ها جدا کنیم. 

این جداسازی به ما کمک می‌کند:
- بتوانیم منطق بیزینسی را به راحتی تست کنیم
- تغییرات در زیرساخت (مثلاً تغییر دیتابیس) تأثیری بر منطق بیزینسی نداشته باشد
- بتوانیم به راحتی مؤلفه‌های مختلف سیستم را به صورت موازی توسعه دهیم
- نگهداری و توسعه طولانی‌مدت سیستم راحت‌تر باشد

هسته مرکزی معماری تمیز، لایه دومین (Domain) است که منطق بیزینسی اصلی در آن قرار می‌گیرد. لایه‌های دیگر (کاربرد، زیرساخت و ارائه) به دور این هسته شکل می‌گیرند.

## بخش Shared - اجزای مشترک سیستم

بخش `shared` در واقع کامپوننت‌هایی را شامل می‌شود که در کل پروژه قابل استفاده هستند. ما این بخش را ایجاد می‌کنیم تا از تکرار کد جلوگیری کنیم و یک استاندارد واحد برای همه ماژول‌ها تعریف کنیم.

### ساختارهای پایه (Base)

در این بخش، ساختارهای پایه‌ای را تعریف می‌کنیم که سایر اجزای سیستم از آنها ارث‌بری می‌کنند.

#### کلاس پایه Entity

چرا به Entity نیاز داریم؟ 
- در دنیای واقعی، اشیاء مختلفی داریم که دارای هویت مشخص هستند، مثل "کاربر شماره ۱۲۳" یا "اشتراک شماره ۴۵۶"
- این اشیاء می‌توانند در طول زمان تغییر کنند، اما هویت آنها ثابت می‌ماند
- ما باید بتوانیم این اشیاء را با هویتشان بازیابی و شناسایی کنیم

در کلاس پایه Entity، ما متدهایی مثل `id()` برای دریافت شناسه، `equals()` برای مقایسه دو Entity بر اساس شناسه، و `hash()` برای محاسبه هش Entity تعریف می‌کنیم. این کلاس پایه یک قرارداد تعریف می‌کند که هر Entity در سیستم باید آن را پیاده‌سازی کند.

#### کلاس پایه AggregateRoot

Aggregate Root مفهومی از الگوهای طراحی Domain-Driven Design (DDD) است. اما چرا به آن نیاز داریم؟
- گاهی Entity‌ها با هم ارتباط نزدیکی دارند و باید به صورت یک واحد مدیریت شوند
- Aggregate Root نقطه ورودی برای دسترسی به این مجموعه است
- تغییرات در Aggregate فقط از طریق Aggregate Root مجاز است
- این باعث می‌شود سازگاری داده‌ها حفظ شود

مثلاً در سیستم ما، `User` یک Aggregate Root است که می‌تواند شامل Entity‌های دیگری مثل اشتراک‌ها، تراکنش‌ها و غیره باشد.

Aggregate Root از Entity ارث‌بری می‌کند و علاوه بر آن، قابلیت‌های مدیریت رویدادها را نیز دارد. متدهای آن شامل:
- `register_event()`: برای ثبت یک رویداد جدید
- `clear_events()`: برای پاک‌سازی رویدادهای ثبت‌شده
- `uncommitted_events()`: برای دسترسی به رویدادهای هنوز منتشر نشده
- `apply_event()`: برای اعمال یک رویداد روی Aggregate
- `from_events()`: برای بازسازی Aggregate از روی مجموعه‌ای از رویدادها

این قابلیت‌ها به ما امکان می‌دهند از الگوی Event Sourcing استفاده کنیم، یعنی بتوانیم تاریخچه تغییرات یک Aggregate را ثبت و بازیابی کنیم.

#### کلاس پایه ValueObject

ValueObject‌ها برخلاف Entity‌ها، با مقادیرشان شناخته می‌شوند، نه با هویتشان. چرا به آنها نیاز داریم؟
- برخی اشیاء در سیستم، ماهیتاً با مقادیرشان تعریف می‌شوند، مثل آدرس ایمیل یا شماره تلفن
- دو Value Object با مقادیر یکسان، معادل یکدیگر هستند (حتی اگر دو شیء متفاوت باشند)
- Value Object‌ها معمولاً غیرقابل تغییر (immutable) هستند
- اگر بخواهیم Value Object را تغییر دهیم، باید یک نمونه جدید بسازیم

مثلاً در سیستم ما، `Email` یک Value Object است که با مقدار آدرس ایمیل تعریف می‌شود.

کلاس پایه ValueObject متدهایی مثل `equals()` برای مقایسه دو Value Object بر اساس مقادیرشان و `validate()` برای اعتبارسنجی مقادیر درونی را تعریف می‌کند.

#### کلاس پایه Event

رویدادها (Events) نشان‌دهنده اتفاقاتی هستند که در دومین رخ داده‌اند. چرا به آنها نیاز داریم؟
- رویدادها به ما کمک می‌کنند تغییرات سیستم را ثبت کنیم
- با استفاده از رویدادها، می‌توانیم اجزای مختلف سیستم را از تغییرات آگاه کنیم (با الگوی Observer)
- رویدادها به ما امکان می‌دهند تاریخچه تغییرات سیستم را داشته باشیم
- با رویدادها می‌توانیم الگوی CQRS (Command Query Responsibility Segregation) را پیاده‌سازی کنیم

مثلاً در سیستم ما، `UserCreated` یک رویداد است که وقتی یک کاربر جدید ایجاد می‌شود، منتشر می‌شود.

کلاس پایه Event متدهایی مثل:
- `event_id()`: برای دریافت شناسه یکتای رویداد
- `event_type()`: برای دریافت نوع رویداد
- `occurred_at()`: برای دریافت زمان وقوع رویداد
- `to_json()`: برای تبدیل رویداد به فرمت JSON
- `from_json()`: برای ساخت رویداد از رشته JSON
- `version()`: برای دریافت نسخه رویداد (برای سازگاری آتی)

این متدها به ما امکان می‌دهند رویدادها را ذخیره، بازیابی و پردازش کنیم.

### سیستم مدیریت خطا

سیستم مدیریت خطا در بخش `shared/error` مسئول مدیریت و پردازش خطاها در کل سیستم است. چرا به یک سیستم مدیریت خطای یکپارچه نیاز داریم؟
- مدیریت متمرکز خطاها به ما کمک می‌کند پیام‌های خطای استاندارد و سازگار داشته باشیم
- می‌توانیم خطاها را طبقه‌بندی کنیم (خطاهای دومین، خطاهای کاربردی و غیره)
- می‌توانیم اطلاعات بیشتری به خطاها اضافه کنیم (مثل متادیتا، زمینه و غیره)
- می‌توانیم خطاها را به پیام‌های قابل فهم برای کاربر تبدیل کنیم

#### خطاهای دومین (DomainError)

خطاهای دومین، خطاهایی هستند که در لایه دومین رخ می‌دهند و مربوط به قوانین بیزینسی هستند. مثلاً:
- اعتبارسنجی ورودی‌ها نادرست است (مثلاً فرمت ایمیل نامعتبر)
- عملیات خاصی مجاز نیست (مثلاً کاربر دسترسی به قابلیت خاصی ندارد)
- داده‌ای وجود ندارد یا تکراری است

کلاس DomainError متدهایی مثل `error_type()`, `message()`, `source()`, `add_context()` و `with_metadata()` را تعریف می‌کند که به ما کمک می‌کنند خطاهای غنی و مفید ایجاد کنیم.

#### خطاهای کاربردی (ApplicationError)

خطاهای کاربردی، خطاهایی هستند که در لایه کاربرد رخ می‌دهند. این خطاها می‌توانند شامل خطاهای دومین نیز باشند. مثلاً:
- نیاز به دسترسی خاصی دارد
- منابع ناکافی هستند
- درخواست نامعتبر است

کلاس ApplicationError متدهایی مثل `error_type()`, `message()`, `source()`, `from_domain_error()` و `status_code()` را تعریف می‌کند که به ما کمک می‌کنند خطاهای دومین را به خطاهای کاربردی تبدیل کنیم و کدهای وضعیت HTTP مناسب را به آنها اختصاص دهیم.

#### مدیریت‌کننده خطا (ErrorHandler)

مدیریت‌کننده خطا، مکانیسم مرکزی برای پردازش خطاها در سیستم است. این کلاس متدهایی مثل `handle()`, `register_handler()` و `with_retry()` را تعریف می‌کند که به ما کمک می‌کنند:
- برای انواع مختلف خطاها، Handler‌های مختلف ثبت کنیم
- خطاها را به صورت مناسب پردازش کنیم
- عملیات‌های ناموفق را چندین بار تلاش کنیم
- خطاهای مشابه را تجمیع کنیم تا از اسپم در لاگ‌ها جلوگیری شود

### ابزارهای کمکی (Utils)

بخش `shared/utils` شامل توابع و ابزارهای کمکی است که در سراسر پروژه استفاده می‌شوند. چرا به این ابزارها نیاز داریم؟
- توابع پرکاربرد را در یک مکان تجمیع می‌کنیم تا از تکرار کد جلوگیری شود
- استانداردسازی عملیات پرکاربرد (مثل فرمت‌بندی تاریخ، محاسبات مالی و غیره)
- افزایش خوانایی و قابلیت نگهداری کد

#### توابع ریاضی (math.rs)

این فایل شامل توابع ریاضی مورد نیاز در پروژه، به خصوص برای محاسبات مالی و آربیتراژ است. مثلاً:
- `calculate_profit_percentage()`: برای محاسبه درصد سود آربیتراژ با احتساب کارمزدها
- `calculate_net_profit()`: برای محاسبه سود خالص آربیتراژ
- `round_decimal()`: برای گرد کردن عدد اعشاری با دقت مشخص
- `weighted_average()`: برای محاسبه میانگین وزنی مجموعه‌ای از اعداد

این توابع به ما کمک می‌کنند محاسبات دقیق و استانداردی داشته باشیم و از خطاهای معمول (مثل گرد کردن نادرست اعداد اعشاری) جلوگیری کنیم.

#### توابع تاریخ و زمان (date.rs)

این فایل شامل توابع مدیریت تاریخ و زمان است که به نیازهای خاص پروژه ما، مثل تبدیل تاریخ میلادی به شمسی، پاسخ می‌دهند. مثلاً:
- `format_date()`: برای فرمت‌بندی تاریخ به رشته با الگوی مشخص
- `convert_to_jalali()`: برای تبدیل تاریخ میلادی به شمسی
- `convert_from_jalali()`: برای تبدیل تاریخ شمسی به میلادی
- `time_ago()`: برای تولید رشته "x زمان پیش" به فارسی
- `is_in_time_range()`: برای بررسی قرار داشتن زمان در بازه مشخص

این توابع به ما کمک می‌کنند با تاریخ‌ها و زمان‌ها به صورت استاندارد و سازگار با نیازهای فرهنگی کاربران ایرانی کار کنیم.

#### توابع رشته (string.rs)

این فایل شامل توابع پردازش و مدیریت رشته‌هاست، به خصوص برای کار با متون فارسی. مثلاً:
- `format_number_fa()`: برای تبدیل عدد به رشته با فرمت فارسی
- `format_price()`: برای فرمت‌بندی قیمت با جداکننده هزارگان
- `normalize_persian_text()`: برای استانداردسازی متن فارسی (تبدیل کاراکترهای عربی)
- `truncate()`: برای کوتاه کردن متن به طول مشخص با اضافه کردن ...
- `slugify()`: برای تبدیل متن به slug مناسب برای URL

این توابع به ما کمک می‌کنند رشته‌ها را به صورت استاندارد و سازگار با نیازهای کاربران ایرانی پردازش کنیم.

#### توابع اعتبارسنجی (validation.rs)

این فایل شامل توابع اعتبارسنجی عمومی برای ورودی‌های کاربر و داده‌هاست. مثلاً:
- `is_valid_email()`: برای بررسی معتبر بودن آدرس ایمیل
- `is_valid_phone()`: برای بررسی معتبر بودن شماره تلفن ایرانی
- `is_valid_password()`: برای بررسی قدرت و معتبر بودن رمز عبور
- `is_valid_national_code()`: برای بررسی معتبر بودن کد ملی ایرانی
- `validate_min_length()`: برای بررسی حداقل طول متن

این توابع به ما کمک می‌کنند ورودی‌های کاربر را به صورت استاندارد و سازگار با نیازهای پروژه اعتبارسنجی کنیم.

#### توابع رمزنگاری (crypto.rs)

این فایل شامل توابع رمزنگاری و هش کردن است. مثلاً:
- `hash_password()`: برای هش کردن رمز عبور با الگوریتم امن
- `verify_password()`: برای بررسی مطابقت رمز عبور با هش
- `generate_otp()`: برای تولید رمز یکبار مصرف با طول مشخص
- `verify_otp()`: برای بررسی معتبر بودن رمز یکبار مصرف
- `generate_secure_token()`: برای تولید توکن امن با طول مشخص

این توابع به ما کمک می‌کنند عملیات امنیتی را به صورت استاندارد و امن انجام دهیم.

### سرویس‌های مشترک (Services)

بخش `shared/services` شامل سرویس‌های مشترک مورد استفاده در سراسر پروژه است. چرا به این سرویس‌ها نیاز داریم؟
- برخی خدمات پایه (مثل ارسال ایمیل) در بخش‌های مختلف پروژه مورد نیاز هستند
- می‌خواهیم این خدمات را یکپارچه و استاندارد ارائه دهیم
- می‌خواهیم از تکرار پیاده‌سازی این خدمات در ماژول‌های مختلف جلوگیری کنیم

#### سرویس ایمیل (email_service.rs)

این سرویس مسئول ارسال ایمیل به کاربران است. متدهای آن شامل:
- `send_email()`: برای ارسال ایمیل ساده
- `send_template_email()`: برای ارسال ایمیل با استفاده از قالب
- `send_verification_email()`: برای ارسال ایمیل تأیید
- `send_password_reset()`: برای ارسال ایمیل بازیابی رمز عبور
- `send_bulk_email()`: برای ارسال ایمیل گروهی

این سرویس به ما کمک می‌کند ایمیل‌ها را به صورت استاندارد، با قابلیت صف‌بندی و مکانیسم retry در صورت شکست، ارسال کنیم.

#### سرویس تلگرام (telegram_service.rs)

این سرویس مسئول ارسال پیام به کاربران از طریق بات تلگرام است. متدهای آن شامل:
- `send_message()`: برای ارسال پیام متنی ساده
- `send_photo()`: برای ارسال تصویر
- `generate_connect_token()`: برای تولید توکن اتصال برای کاربر
- `verify_connect_token()`: برای بررسی و تأیید توکن اتصال
- `is_connected()`: برای بررسی اتصال کاربر به تلگرام

این سرویس به ما کمک می‌کند با API تلگرام به صورت ایمن ارتباط برقرار کنیم و پیام‌ها را با قابلیت صف‌بندی و مدیریت خطاها ارسال کنیم.

#### سرویس اعلان (notification_service.rs)

این سرویس مسئول ارسال انواع اعلان به کاربران است. متدهای آن شامل:
- `send_notification()`: برای ارسال اعلان به کاربر
- `send_arbitrage_notification()`: برای ارسال اعلان فرصت آربیتراژ
- `send_subscription_notification()`: برای ارسال اعلان مرتبط با اشتراک
- `send_system_notification()`: برای ارسال اعلان سیستمی
- `should_send_notification()`: برای بررسی مجاز بودن ارسال اعلان به کاربر

این سرویس به ما کمک می‌کند اعلان‌ها را به صورت هوشمند، با توجه به ترجیحات و دسترسی کاربر، ارسال کنیم. همچنین می‌توانیم اعلان‌ها را صف‌بندی و اولویت‌بندی کنیم و آنها را فقط در محدوده زمانی مجاز کاربر ارسال کنیم.

## ماژول User: مدیریت کاربران و اشتراک‌ها

ماژول User مسئول مدیریت کاربران، اشتراک‌ها، تراکنش‌ها و سیستم رفرال است. این ماژول به جای اینکه به چند ماژول کوچکتر تقسیم شود، به صورت یکپارچه طراحی شده تا پیچیدگی کاهش یابد.

### Entity‌های ماژول User

#### Entity کاربر (User)

Entity کاربر، هسته اصلی ماژول User است و اطلاعات اصلی کاربران سیستم را نگهداری می‌کند. این Entity شامل اطلاعاتی مثل:
- اطلاعات شناسایی: ایمیل، شماره تلفن، نام، نام خانوادگی
- اطلاعات امنیتی: رمز عبور، وضعیت (فعال، غیرفعال، مسدود)
- اطلاعات تلگرام: شناسه تلگرام، شناسه چت، وضعیت اتصال
- اطلاعات رفرال: کد معرفی، شناسه کاربر معرف

متدهای اصلی این Entity عبارتند از:
- `new()`: برای ایجاد نمونه جدید کاربر با اعتبارسنجی
- `update_profile()`: برای به‌روزرسانی پروفایل کاربر
- `change_password()`: برای تغییر رمز عبور با اعتبارسنجی
- `verify_email()`: برای تأیید ایمیل کاربر
- `verify_phone()`: برای تأیید شماره تلفن کاربر
- `connect_telegram()`: برای اتصال حساب کاربری به تلگرام
- `disconnect_telegram()`: برای قطع اتصال حساب کاربری از تلگرام
- `change_status()`: برای تغییر وضعیت کاربر
- `has_access_to_feature()`: برای بررسی دسترسی کاربر به قابلیت خاص

چرا به این متدها نیاز داریم؟ چون می‌خواهیم عملیات روی Entity کاربر را کنترل کنیم و اطمینان حاصل کنیم که داده‌ها در وضعیت معتبر باقی می‌مانند. مثلاً با متد `change_password()` می‌توانیم بررسی کنیم که رمز عبور جدید با رمز عبور قبلی یکسان نیست، یا با متد `verify_email()` می‌توانیم تاریخ تأیید ایمیل را ثبت کنیم.

#### Entity اشتراک (Subscription)

Entity اشتراک، اطلاعات مربوط به اشتراک‌های خریداری شده توسط کاربران را نگهداری می‌کند. این Entity شامل اطلاعاتی مثل:
- اطلاعات کاربر: شناسه کاربر مالک اشتراک
- اطلاعات پلن: نوع پلن، قیمت اصلی، قیمت نهایی، تخفیف
- اطلاعات زمانی: تاریخ شروع، تاریخ پایان، وضعیت (فعال، منقضی، لغو شده)
- تنظیمات: تمدید خودکار

متدهای اصلی این Entity عبارتند از:
- `new()`: برای ایجاد اشتراک جدید
- `apply_discount()`: برای اعمال کد تخفیف و محاسبه قیمت نهایی
- `activate()`: برای فعال‌سازی اشتراک
- `cancel()`: برای لغو اشتراک
- `expire()`: برای منقضی کردن اشتراک
- `renew()`: برای تمدید اشتراک
- `is_active()`: برای بررسی فعال بودن اشتراک
- `days_left()`: برای محاسبه روزهای باقی‌مانده اشتراک
- `can_access_feature()`: برای بررسی دسترسی به قابلیت خاص

چرا به این متدها نیاز داریم؟ چون می‌خواهیم چرخه حیات اشتراک را مدیریت کنیم و دسترسی کاربر به قابلیت‌های مختلف را بر اساس نوع اشتراک کنترل کنیم. مثلاً با متد `is_active()` می‌توانیم بررسی کنیم که آیا اشتراک هنوز معتبر است، یا با متد `days_left()` می‌توانیم به کاربر اطلاع دهیم چند روز تا پایان اشتراکش باقی مانده است.

#### Entity تراکنش (Transaction)

Entity تراکنش، اطلاعات مربوط به تراکنش‌های مالی کاربران را نگهداری می‌کند. این Entity شامل اطلاعاتی مثل:
- اطلاعات کاربر: شناسه کاربر مرتبط با تراکنش
- اطلاعات مالی: نوع تراکنش، مبلغ، توضیحات
- اطلاعات پرداخت: درگاه پرداخت، شناسه پرداخت، شماره پیگیری
- اطلاعات وضعیت: وضعیت تراکنش (موفق، ناموفق، در انتظار)
- ارتباطات: شناسه اشتراک مرتبط

متدهای اصلی این Entity عبارتند از:
- `new()`: برای ایجاد تراکنش جدید
- `mark_as_successful()`: برای ثبت موفقیت تراکنش
- `mark_as_failed()`: برای ثبت شکست تراکنش
- `is_successful()`: برای بررسی موفقیت تراکنش
- `is_pending()`: برای بررسی در انتظار بودن تراکنش
- `is_related_to_subscription()`: برای بررسی ارتباط با اشتراک

چرا به این متدها نیاز داریم؟ چون می‌خواهیم جریان پرداخت را کنترل کنیم و وضعیت تراکنش‌ها را مدیریت کنیم. مثلاً با متد `mark_as_successful()` می‌توانیم تراکنش را به عنوان موفق علامت‌گذاری کنیم و اطلاعات پرداخت را ثبت کنیم، یا با متد `is_pending()` می‌توانیم تراکنش‌های در انتظار را شناسایی کنیم و آنها را پیگیری کنیم.

#### Entity رفرال (Referral)

Entity رفرال، اطلاعات مربوط به سیستم معرفی کاربران را نگهداری می‌کند. این Entity رابطه بین کاربر معرف و کاربر معرفی‌شده را مدیریت می‌کند. این Entity شامل اطلاعاتی مثل:
- اطلاعات کاربران: شناسه کاربر معرف، شناسه کاربر معرفی‌شده
- اطلاعات کمیسیون: درصد کمیسیون، مبلغ کمیسیون، وضعیت کمیسیون
- اطلاعات پرداخت: زمان پرداخت، شناسه تراکنش پرداخت
- ارتباطات: شناسه اشتراک خریداری شده

متدهای اصلی این Entity عبارتند از:
- `new()`: برای ایجاد رابطه رفرال جدید
- `complete_with_subscription()`: برای ثبت خرید اشتراک و محاسبه کمیسیون
- `mark_as_paid()`: برای ثبت پرداخت کمیسیون
- `mark_as_used()`: برای ثبت استفاده از کمیسیون برای خرید
- `is_paid()`: برای بررسی پرداخت شدن کمیسیون
- `is_unpaid()`: برای بررسی پرداخت نشدن کمیسیون

چرا به این متدها نیاز داریم؟ چون می‌خواهیم سیستم رفرال را مدیریت کنیم و کمیسیون‌ها را محاسبه و پرداخت کنیم. مثلاً با متد `complete_with_subscription()` می‌توانیم وقتی کاربر معرفی‌شده اشتراک خریداری می‌کند، کمیسیون را محاسبه کنیم، یا با متد `mark_as_paid()` می‌توانیم پرداخت کمیسیون را ثبت کنیم.

#### Entity موجودی کاربر (UserBalance)

Entity موجودی کاربر، تاریخچه تغییرات موجودی کاربر را نگهداری می‌کند. این Entity شامل اطلاعاتی مثل:
- اطلاعات کاربر: شناسه کاربر
- اطلاعات مالی: مبلغ تغییر (مثبت یا منفی)، موجودی پس از تغییر
- اطلاعات نوع: نوع تغییر موجودی، توضیحات تغییر
- ارتباطات: شناسه مرجع، نوع مرجع

متدهای اصلی این Entity عبارتند از:
- `new()`: برای ایجاد رکورد تغییر موجودی جدید
- `create_from_referral()`: برای ایجاد تغییر موجودی از رفرال
- `create_from_withdrawal()`: برای ایجاد تغییر موجودی از برداشت
- `is_income()`: برای بررسی افزایشی بودن تغییر
- `is_expense()`: برای بررسی کاهشی بودن تغییر

چرا به این متدها نیاز داریم؟ چون می‌خواهیم تغییرات موجودی کاربر را ثبت کنیم و تاریخچه کاملی از تراکنش‌های مالی کاربر داشته باشیم. مثلاً با متد `create_from_referral()` می‌توانیم وقتی کمیسیون رفرال به کاربر تعلق می‌گیرد، موجودی او را افزایش دهیم، یا با متد `is_income()` می‌توانیم نوع تغییر را بررسی کنیم.

#### Entity کد تخفیف (DiscountCode)

Entity کد تخفیف، اطلاعات مربوط به کدهای تخفیف قابل استفاده در سیستم را نگهداری می‌کند. این Entity شامل اطلاعاتی مثل:
- اطلاعات پایه: کد، توضیحات
- اطلاعات تخفیف: نوع تخفیف (درصدی/مبلغ ثابت)، مقدار تخفیف
- محدودیت‌ها: حداقل مبلغ خرید، حداکثر دفعات استفاده، تعداد استفاده تاکنون
- محدودیت‌های زمانی: تاریخ شروع اعتبار، تاریخ پایان اعتبار
- وضعیت: فعال بودن

متدهای اصلی این Entity عبارتند از:
- `new()`: برای ایجاد کد تخفیف جدید
- `validate()`: برای اعتبارسنجی امکان استفاده از کد
- `calculate_discount()`: برای محاسبه مبلغ تخفیف
- `use_code()`: برای ثبت استفاده از کد
- `is_valid()`: برای بررسی معتبر بودن کد
- `is_expired()`: برای بررسی منقضی شدن کد
- `is_applicable_to_plan()`: برای بررسی قابلیت استفاده برای پلن

چرا به این متدها نیاز داریم؟ چون می‌خواهیم سیستم کد تخفیف را مدیریت کنیم و اطمینان حاصل کنیم که کدها فقط در شرایط معتبر قابل استفاده هستند. مثلاً با متد `validate()` می‌توانیم بررسی کنیم که آیا کاربر می‌تواند از کد تخفیف استفاده کند، یا با متد `calculate_discount()` می‌توانیم مبلغ تخفیف را محاسبه کنیم.

### Value Object‌های ماژول User

#### Value Object آدرس ایمیل (Email)

این Value Object، مقدار آدرس ایمیل را نگهداری می‌کند و اعتبارسنجی آن را انجام می‌دهد. متدهای اصلی آن عبارتند از:
- `new()`: برای ایجاد نمونه جدید با اعتبارسنجی
- `value()`: برای دریافت مقدار ایمیل
- `is_verified()`: برای بررسی تأیید شدن ایمیل

چرا به این Value Object نیاز داریم؟ چون می‌خواهیم اطمینان حاصل کنیم که آدرس‌های ایمیل معتبر هستند و به صورت استاندارد ذخیره می‌شوند. همچنین می‌خواهیم از تکرار کد اعتبارسنجی ایمیل در نقاط مختلف برنامه جلوگیری کنیم.

#### Value Object شماره تلفن (Phone)

این Value Object، مقدار شماره تلفن را نگهداری می‌کند و اعتبارسنجی آن را انجام می‌دهد. متدهای اصلی آن عبارتند از:
- `new()`: برای ایجاد نمونه جدید با اعتبارسنجی
- `value()`: برای دریافت مقدار شماره تلفن
- `formatted()`: برای دریافت شماره تلفن فرمت‌بندی شده
- `is_verified()`: برای بررسی تأیید شدن شماره تلفن

چرا به این Value Object نیاز داریم؟ چون می‌خواهیم اطمینان حاصل کنیم که شماره‌های تلفن معتبر هستند و به صورت استاندارد ذخیره می‌شوند. همچنین می‌خواهیم از تکرار کد اعتبارسنجی شماره تلفن در نقاط مختلف برنامه جلوگیری کنیم.

#### Value Object رمز عبور (Password)

این Value Object، هش رمز عبور را نگهداری می‌کند و عملیات مرتبط با آن را انجام می‌دهد. متدهای اصلی آن عبارتند از:
- `from_plain()`: برای ایجاد از رمز عبور متنی با هش کردن
- `from_hash()`: برای ایجاد از هش موجود
- `verify()`: برای بررسی مطابقت رمز عبور با هش
- `needs_rehash()`: برای بررسی نیاز به هش مجدد با الگوریتم جدیدتر

چرا به این Value Object نیاز داریم؟ چون می‌خواهیم اطمینان حاصل کنیم که رمزهای عبور به صورت امن ذخیره می‌شوند و مدیریت آنها استاندارد است. همچنین می‌خواهیم از تکرار کد هش کردن و بررسی رمز عبور در نقاط مختلف برنامه جلوگیری کنیم.

#### Value Object مقدار پولی (Money)

این Value Object، مقدار پولی را نگهداری می‌کند و عملیات مرتبط با آن را انجام می‌دهد. متدهای اصلی آن عبارتند از:
- `new()`: برای ایجاد نمونه جدید
- `amount()`: برای دریافت مقدار
- `currency()`: برای دریافت واحد پولی
- `add()`: برای جمع دو مقدار پولی
- `subtract()`: برای تفریق دو مقدار پولی
- `multiply()`: برای ضرب مقدار پولی در عدد
- `apply_discount()`: برای اعمال درصد تخفیف
- `formatted()`: برای دریافت رشته فرمت‌بندی شده با واحد پولی

چرا به این Value Object نیاز داریم؟ چون می‌خواهیم اطمینان حاصل کنیم که محاسبات مالی دقیق انجام می‌شوند و از خطاهای گرد کردن جلوگیری می‌شود. همچنین می‌خواهیم عملیات‌های پایه ریاضی را برای مقادیر پولی به صورت استاندارد انجام دهیم.

#### Value Object پلن اشتراک (SubscriptionPlan)

این Value Object، اطلاعات مربوط به یک پلن اشتراک را نگهداری می‌کند. متدهای اصلی آن عبارتند از:
- `new()`: برای ایجاد نمونه جدید
- `is_free()`: برای بررسی رایگان بودن پلن
- `has_feature()`: برای بررسی وجود ویژگی در پلن
- `is_better_than()`: برای مقایسه با پلن دیگر
- `calculate_end_date()`: برای محاسبه تاریخ پایان

چرا به این Value Object نیاز داریم؟ چون می‌خواهیم اطلاعات پلن‌های اشتراک را به صورت منسجم نگهداری کنیم و بتوانیم آنها را مقایسه کنیم. همچنین می‌خواهیم بدانیم هر پلن چه ویژگی‌هایی دارد و چه محدودیت‌هایی دارد.

#### Value Object وضعیت اشتراک (SubscriptionStatus)

این Value Object، وضعیت یک اشتراک را نگهداری می‌کند. مقادیر مجاز آن عبارتند از: `Active`, `Expired`, `Cancelled`. متدهای اصلی آن عبارتند از:
- `is_active()`: برای بررسی فعال بودن
- `is_expired()`: برای بررسی منقضی بودن
- `is_cancelled()`: برای بررسی لغو شدن
- `can_be_changed_to()`: برای بررسی امکان تغییر به وضعیت دیگر
- `display_name()`: برای دریافت نام نمایشی وضعیت

چرا به این Value Object نیاز داریم؟ چون می‌خواهیم وضعیت‌های مختلف اشتراک را به صورت استاندارد مدیریت کنیم و قوانین انتقال بین وضعیت‌ها را تعریف کنیم. مثلاً ممکن است نخواهیم اشتراک لغو شده را به وضعیت فعال برگردانیم.

#### Value Object نوع تراکنش (TransactionType)

این Value Object، نوع یک تراکنش را نگهداری می‌کند. مقادیر مجاز آن عبارتند از: `SubscriptionPurchase`, `ReferralCommission`, `ReferralWithdrawal`, `AccountCharge`. متدهای اصلی آن عبارتند از:
- `is_income()`: برای بررسی درآمد بودن تراکنش
- `is_expense()`: برای بررسی هزینه بودن تراکنش
- `affects_balance()`: برای بررسی تأثیر بر موجودی
- `display_name()`: برای دریافت نام نمایشی نوع تراکنش

چرا به این Value Object نیاز داریم؟ چون می‌خواهیم انواع مختلف تراکنش را به صورت استاندارد مدیریت کنیم و بدانیم هر نوع تراکنش چه تأثیری بر موجودی کاربر دارد. مثلاً تراکنش خرید اشتراک یک هزینه است، در حالی که تراکنش کمیسیون رفرال یک درآمد است.

#### Value Object کد معرفی (ReferralCode)

این Value Object، کد معرفی یک کاربر را نگهداری می‌کند. متدهای اصلی آن عبارتند از:
- `new()`: برای ایجاد کد معرفی جدید تصادفی
- `from_string()`: برای ایجاد از رشته موجود با اعتبارسنجی
- `to_string()`: برای تبدیل به رشته
- `is_valid()`: برای بررسی معتبر بودن فرمت

چرا به این Value Object نیاز داریم؟ چون می‌خواهیم اطمینان حاصل کنیم که کدهای معرفی معتبر هستند و به صورت استاندارد ذخیره می‌شوند. همچنین می‌خواهیم بتوانیم کدهای معرفی را به راحتی تولید کنیم.

### رویدادهای ماژول User

#### رویداد ایجاد کاربر (UserCreated)

این رویداد زمانی منتشر می‌شود که یک کاربر جدید در سیستم ایجاد می‌شود. فیلدهای اصلی آن عبارتند از:
- `user_id`: شناسه کاربر ایجاد شده
- `email`: ایمیل کاربر
- `phone`: شماره تلفن کاربر
- `timestamp`: زمان ایجاد کاربر

چرا به این رویداد نیاز داریم؟ چون می‌خواهیم بخش‌های مختلف سیستم را از ایجاد کاربر جدید مطلع کنیم. مثلاً ممکن است بخواهیم به کاربر جدید یک ایمیل خوش‌آمدگویی ارسال کنیم، یا او را در یک کمپین بازاریابی ثبت‌نام کنیم.

#### رویداد به‌روزرسانی کاربر (UserUpdated)

این رویداد زمانی منتشر می‌شود که اطلاعات یک کاربر به‌روزرسانی می‌شود. فیلدهای اصلی آن عبارتند از:
- `user_id`: شناسه کاربر
- `updated_fields`: فیلدهای به‌روزرسانی شده
- `timestamp`: زمان به‌روزرسانی

چرا به این رویداد نیاز داریم؟ چون می‌خواهیم بخش‌های مختلف سیستم را از تغییرات در اطلاعات کاربر مطلع کنیم. مثلاً اگر کاربر ایمیل خود را تغییر دهد، ممکن است بخواهیم یک ایمیل تأیید به آدرس جدید ارسال کنیم.

#### رویداد خرید اشتراک (SubscriptionPurchased)

این رویداد زمانی منتشر می‌شود که یک کاربر اشتراک جدید خریداری می‌کند. فیلدهای اصلی آن عبارتند از:
- `subscription_id`: شناسه اشتراک
- `user_id`: شناسه کاربر
- `plan_id`: شناسه پلن
- `price`: قیمت پرداخت شده
- `start_date`: تاریخ شروع اشتراک
- `end_date`: تاریخ پایان اشتراک
- `timestamp`: زمان خرید

چرا به این رویداد نیاز داریم؟ چون می‌خواهیم بخش‌های مختلف سیستم را از خرید اشتراک جدید مطلع کنیم. مثلاً ممکن است بخواهیم به کاربر یک ایمیل تأیید خرید ارسال کنیم، یا در صورت معرفی شدن کاربر توسط فرد دیگر، کمیسیون رفرال را محاسبه و پرداخت کنیم.

#### رویداد انقضای اشتراک (SubscriptionExpired)

این رویداد زمانی منتشر می‌شود که اشتراک یک کاربر منقضی می‌شود. فیلدهای اصلی آن عبارتند از:
- `subscription_id`: شناسه اشتراک
- `user_id`: شناسه کاربر
- `plan_id`: شناسه پلن
- `expiry_date`: تاریخ انقضا
- `timestamp`: زمان ثبت انقضا

چرا به این رویداد نیاز داریم؟ چون می‌خواهیم بخش‌های مختلف سیستم را از انقضای اشتراک مطلع کنیم. مثلاً ممکن است بخواهیم به کاربر یک اعلان یا ایمیل یادآوری برای تمدید اشتراک ارسال کنیم.

#### رویداد تکمیل معرفی (ReferralCompleted)

این رویداد زمانی منتشر می‌شود که کاربر معرفی‌شده اشتراک خریداری می‌کند. فیلدهای اصلی آن عبارتند از:
- `referral_id`: شناسه رفرال
- `referrer_id`: شناسه کاربر معرف
- `referred_id`: شناسه کاربر معرفی‌شده
- `subscription_id`: شناسه اشتراک خریداری شده
- `commission_amount`: مبلغ کمیسیون
- `timestamp`: زمان تکمیل

چرا به این رویداد نیاز داریم؟ چون می‌خواهیم بخش‌های مختلف سیستم را از تکمیل رفرال مطلع کنیم. مثلاً ممکن است بخواهیم به کاربر معرف یک اعلان ارسال کنیم و به او اطلاع دهیم که کمیسیون دریافت کرده است.

#### رویداد کسب کمیسیون (CommissionEarned)

این رویداد زمانی منتشر می‌شود که یک کاربر کمیسیون رفرال دریافت می‌کند. فیلدهای اصلی آن عبارتند از:
- `user_id`: شناسه کاربر
- `referral_id`: شناسه رفرال
- `amount`: مبلغ کمیسیون
- `timestamp`: زمان کسب کمیسیون

چرا به این رویداد نیاز داریم؟ چون می‌خواهیم بخش‌های مختلف سیستم را از دریافت کمیسیون توسط کاربر مطلع کنیم. مثلاً ممکن است بخواهیم موجودی کاربر را به‌روزرسانی کنیم یا یک اعلان به او ارسال کنیم.

### سرویس‌های ماژول User

#### سرویس احراز هویت (AuthenticationService)

این سرویس مسئول احراز هویت کاربران است. متدهای اصلی آن عبارتند از:
- `register()`: برای ثبت‌نام کاربر جدید
- `login()`: برای ورود کاربر با ایمیل/تلفن و رمز عبور
- `verify_email()`: برای تأیید ایمیل کاربر
- `verify_phone()`: برای تأیید شماره تلفن کاربر
- `request_password_reset()`: برای درخواست بازیابی رمز عبور
- `reset_password()`: برای بازیابی رمز عبور
- `change_password()`: برای تغییر رمز عبور

چرا به این سرویس نیاز داریم؟ چون می‌خواهیم عملیات مربوط به احراز هویت کاربران را در یک نقطه متمرکز کنیم و منطق بیزینسی مربوط به آن را پیاده‌سازی کنیم. مثلاً در متد `login()` می‌خواهیم بررسی کنیم که آیا کاربر با ایمیل/تلفن و رمز عبور داده شده وجود دارد و آیا حساب او فعال است.

#### سرویس مدیریت اشتراک (SubscriptionService)

این سرویس مسئول مدیریت اشتراک‌های کاربران است. متدهای اصلی آن عبارتند از:
- `get_plans()`: برای دریافت لیست پلن‌های اشتراک
- `get_user_subscription()`: برای دریافت اشتراک فعال کاربر
- `purchase_subscription()`: برای خرید اشتراک جدید
- `cancel_subscription()`: برای لغو اشتراک
- `renew_subscription()`: برای تمدید اشتراک
- `check_access()`: برای بررسی دسترسی کاربر به ویژگی
- `expire_outdated_subscriptions()`: برای منقضی کردن اشتراک‌های قدیمی

چرا به این سرویس نیاز داریم؟ چون می‌خواهیم عملیات مربوط به اشتراک‌ها را در یک نقطه متمرکز کنیم و منطق بیزینسی مربوط به آن را پیاده‌سازی کنیم. مثلاً در متد `purchase_subscription()` می‌خواهیم یک اشتراک جدید برای کاربر ایجاد کنیم، قیمت نهایی را با توجه به تخفیف‌ها محاسبه کنیم و تراکنش مربوطه را ثبت کنیم.

#### سرویس مدیریت رفرال (ReferralService)

این سرویس مسئول مدیریت سیستم رفرال است. متدهای اصلی آن عبارتند از:
- `register_referral()`: برای ثبت رابطه رفرال جدید
- `process_subscription_purchase()`: برای پردازش خرید اشتراک و محاسبه کمیسیون
- `get_user_referrals()`: برای دریافت لیست رفرال‌های کاربر
- `get_unpaid_commissions()`: برای دریافت کمیسیون‌های پرداخت نشده
- `get_total_commission()`: برای محاسبه کل کمیسیون کاربر
- `withdraw_commission()`: برای برداشت کمیسیون
- `use_commission_for_purchase()`: برای استفاده از کمیسیون برای خرید اشتراک

چرا به این سرویس نیاز داریم؟ چون می‌خواهیم عملیات مربوط به سیستم رفرال را در یک نقطه متمرکز کنیم و منطق بیزینسی مربوط به آن را پیاده‌سازی کنیم. مثلاً در متد `process_subscription_purchase()` می‌خواهیم بررسی کنیم که آیا کاربر از طریق سیستم رفرال معرفی شده است، و اگر چنین است، کمیسیون مربوطه را محاسبه و به کاربر معرف اختصاص دهیم.

#### سرویس مدیریت پرداخت (PaymentService)

این سرویس مسئول مدیریت پرداخت‌ها است. متدهای اصلی آن عبارتند از:
- `create_payment()`: برای ایجاد تراکنش جدید
- `generate_payment_url()`: برای تولید URL پرداخت
- `verify_payment()`: برای تأیید پرداخت بازگشتی از درگاه
- `apply_discount_code()`: برای اعمال کد تخفیف و محاسبه قیمت نهایی
- `get_transaction_history()`: برای دریافت تاریخچه تراکنش‌های کاربر
- `cancel_transaction()`: برای لغو تراکنش
- `get_transaction_status()`: برای دریافت وضعیت تراکنش

چرا به این سرویس نیاز داریم؟ چون می‌خواهیم عملیات مربوط به پرداخت را در یک نقطه متمرکز کنیم و منطق بیزینسی مربوط به آن را پیاده‌سازی کنیم. مثلاً در متد `verify_payment()` می‌خواهیم بررسی کنیم که آیا پرداخت با موفقیت انجام شده است، و اگر چنین است، تراکنش مربوطه را به‌روزرسانی کنیم و اشتراک کاربر را فعال کنیم.

## ماژول Arbitrage: تشخیص فرصت‌های آربیتراژ

ماژول Arbitrage مسئول مدیریت صرافی‌ها، تشخیص فرصت‌های آربیتراژ و ارسال اعلان‌ها به کاربران است. این ماژول‌ها به دلیل ارتباط نزدیک با یکدیگر، در یک ماژول واحد ادغام شده‌اند تا پیچیدگی کاهش یابد.

### Entity‌های ماژول Arbitrage

#### Entity صرافی (Exchange)

این Entity اطلاعات مربوط به صرافی‌های ارز دیجیتال را نگهداری می‌کند. فیلدهای اصلی آن عبارتند از:
- اطلاعات پایه: نام، لوگو، نام مستعار (slug)، آدرس وب‌سایت
- اطلاعات API: آدرس پایه API، وضعیت API (فعال، غیرفعال، تعمیر)
- اطلاعات توضیحی: توضیح کوتاه، توضیحات کامل، مزایا، معایب
- وضعیت: پشتیبانی از معاملات ریالی، فعال بودن

متدهای اصلی این Entity عبارتند از:
- `new()`: برای ایجاد نمونه جدید صرافی
- `update_info()`: برای به‌روزرسانی اطلاعات صرافی
- `update_api_status()`: برای به‌روزرسانی وضعیت API
- `activate()`: برای فعال کردن صرافی
- `deactivate()`: برای غیرفعال کردن صرافی
- `add_pros()`: برای افزودن مزایا
- `add_cons()`: برای افزودن معایب

چرا به این Entity نیاز داریم؟ چون می‌خواهیم اطلاعات صرافی‌ها را در سیستم نگهداری کنیم تا بتوانیم قیمت‌های ارزها را در آنها دریافت و مقایسه کنیم. همچنین می‌خواهیم به کاربران اطلاعاتی درباره هر صرافی ارائه دهیم تا بتوانند آگاهانه تصمیم بگیرند.

#### Entity کارمزد صرافی (ExchangeFee)

این Entity اطلاعات مربوط به کارمزدهای صرافی‌ها را نگهداری می‌کند. فیلدهای اصلی آن عبارتند از:
- ارتباطات: شناسه صرافی، شناسه ارز (اختیاری)
- اطلاعات کارمزد: نوع کارمزد، درصد کارمزد، مبلغ ثابت کارمزد، حداقل/حداکثر مبلغ کارمزد
- اطلاعات واحد: واحد پولی کارمزد
- اطلاعات زمانی: تاریخ شروع اعمال، تاریخ پایان اعمال
- وضعیت: فعال بودن

متدهای اصلی این Entity عبارتند از:
- `new()`: برای ایجاد کارمزد جدید
- `calculate_fee()`: برای محاسبه مبلغ کارمزد برای مقدار مشخص
- `is_valid_at()`: برای بررسی اعتبار در تاریخ مشخص
- `is_expired()`: برای بررسی منقضی بودن
- `update()`: برای به‌روزرسانی مقادیر کارمزد
- `deactivate()`: برای غیرفعال کردن کارمزد

چرا به این Entity نیاز داریم؟ چون می‌خواهیم کارمزدهای صرافی‌ها را در محاسبات آربیتراژ لحاظ کنیم. کارمزدها می‌توانند تأثیر قابل توجهی بر سودآوری یک فرصت آربیتراژ داشته باشند، بنابراین باید آنها را به دقت مدیریت کنیم.

#### Entity ارز دیجیتال (Cryptocurrency)

این Entity اطلاعات مربوط به ارزهای دیجیتال را نگهداری می‌کند. فیلدهای اصلی آن عبارتند از:
- اطلاعات پایه: نام کامل (مثلاً Bitcoin)، نماد (مثلاً BTC)، نام مستعار (slug)، لوگو
- اطلاعات توضیحی: توضیح کوتاه فارسی، توضیحات کامل فارسی
- اطلاعات بازار: ارزش بازار به دلار
- وضعیت: استیبل کوین بودن، فعال بودن

متدهای اصلی این Entity عبارتند از:
- `new()`: برای ایجاد ارز دیجیتال جدید
- `update_info()`: برای به‌روزرسانی اطلاعات ارز
- `update_market_data()`: برای به‌روزرسانی داده‌های بازار
- `activate()`: برای فعال کردن ارز
- `deactivate()`: برای غیرفعال کردن ارز
- `standardize_symbol()`: برای استانداردسازی نماد ارز

چرا به این Entity نیاز داریم؟ چون می‌خواهیم اطلاعات ارزهای دیجیتال را در سیستم نگهداری کنیم تا بتوانیم قیمت‌های آنها را در صرافی‌های مختلف دریافت و مقایسه کنیم. همچنین می‌خواهیم به کاربران اطلاعاتی درباره هر ارز ارائه دهیم تا بتوانند آگاهانه تصمیم بگیرند.

#### Entity قیمت ارز (CryptoPrice)

این Entity اطلاعات مربوط به قیمت‌های ارزهای دیجیتال در صرافی‌ها را نگهداری می‌کند. فیلدهای اصلی آن عبارتند از:
- ارتباطات: شناسه ارز دیجیتال، شناسه صرافی
- اطلاعات قیمت: قیمت خرید به تومان، قیمت فروش به تومان
- اطلاعات زمانی: زمان ثبت قیمت
- اطلاعات بازار: حجم معاملات 24 ساعته، بالاترین/پایین‌ترین قیمت 24 ساعته، درصد تغییر قیمت 24 ساعته
- اطلاعات منبع: منبع داده (API، web scraping)

متدهای اصلی این Entity عبارتند از:
- `new()`: برای ایجاد قیمت جدید
- `calculate_spread()`: برای محاسبه اختلاف قیمت خرید و فروش
- `calculate_spread_percentage()`: برای محاسبه درصد اختلاف قیمت
- `is_fresh()`: برای بررسی تازگی داده‌های قیمت
- `price_difference_from()`: برای محاسبه اختلاف قیمت با قیمت دیگر

چرا به این Entity نیاز داریم؟ چون می‌خواهیم قیمت‌های ارزها را در صرافی‌های مختلف نگهداری کنیم تا بتوانیم آنها را مقایسه کنیم و فرصت‌های آربیتراژ را تشخیص دهیم. همچنین می‌خواهیم اطلاعات بازار را نگهداری کنیم تا به کاربران ارائه دهیم.

#### Entity فرصت آربیتراژ (ArbitrageOpportunity)

این Entity اطلاعات مربوط به فرصت‌های آربیتراژ را نگهداری می‌کند. فیلدهای اصلی آن عبارتند از:
- ارتباطات: شناسه ارز دیجیتال، شناسه صرافی خرید، شناسه صرافی فروش
- اطلاعات قیمت: قیمت خرید در صرافی مبدأ، قیمت فروش در صرافی مقصد
- اطلاعات سود: درصد سود خالص، درصد کارمزد خرید، درصد کارمزد فروش، سود تخمینی برای یک واحد ارز
- اطلاعات زمانی: زمان کشف فرصت، مدت زمان باز بودن فرصت
- وضعیت: فعال بودن فرصت

متدهای اصلی این Entity عبارتند از:
- `new()`: برای ایجاد فرصت آربیتراژ جدید
- `calculate_profit()`: برای محاسبه سود برای مقدار مشخص
- `is_profitable()`: برای بررسی سودآور بودن بر اساس حداقل درصد سود
- `close()`: برای بستن فرصت و ثبت مدت زمان فعال بودن
- `get_exchanges()`: برای دریافت صرافی‌های مبدأ و مقصد
- `get_profit_description()`: برای تولید توضیح فرصت آربیتراژ

چرا به این Entity نیاز داریم؟ چون می‌خواهیم فرصت‌های آربیتراژ را در سیستم نگهداری کنیم تا بتوانیم آنها را به کاربران اعلام کنیم. همچنین می‌خواهیم اطلاعات مربوط به سودآوری هر فرصت را نگهداری کنیم تا بتوانیم فرصت‌ها را رتبه‌بندی کنیم.

#### Entity اعلان (Notification)

این Entity اطلاعات مربوط به اعلان‌های ارسال شده به کاربران را نگهداری می‌کند. فیلدهای اصلی آن عبارتند از:
- ارتباطات: شناسه کاربر دریافت‌کننده
- اطلاعات پایه: نوع اعلان، عنوان اعلان، محتوای اعلان
- اطلاعات اضافی: داده‌های اضافی به فرمت JSON
- وضعیت: خوانده شدن، زمان خواندن
- اطلاعات ارسال: کانال ارسال، موفقیت ارسال، پیام خطا در صورت عدم موفقیت
- اطلاعات زمانی: زمان ایجاد اعلان، زمان ارسال اعلان

متدهای اصلی این Entity عبارتند از:
- `new()`: برای ایجاد اعلان جدید
- `mark_as_read()`: برای علامت‌گذاری به عنوان خوانده شده
- `mark_as_sent()`: برای علامت‌گذاری به عنوان ارسال شده
- `mark_as_failed()`: برای علامت‌گذاری به عنوان ناموفق
- `is_arbitrage_notification()`: برای بررسی مربوط به فرصت آربیتراژ بودن
- `get_opportunity_id()`: برای دریافت شناسه فرصت آربیتراژ مرتبط

چرا به این Entity نیاز داریم؟ چون می‌خواهیم اعلان‌های ارسال شده به کاربران را در سیستم نگهداری کنیم تا بتوانیم وضعیت آنها را مدیریت کنیم و از اعلان‌های تکراری جلوگیری کنیم. همچنین می‌خواهیم بدانیم چه اعلان‌هایی به کاربران ارسال شده است تا بتوانیم آمار و تحلیل داشته باشیم.

### سرویس‌های ماژول Arbitrage

#### سرویس مدیریت صرافی (ExchangeService)

این سرویس مسئول مدیریت صرافی‌ها است. متدهای اصلی آن عبارتند از:
- `get_all_exchanges()`: برای دریافت لیست همه صرافی‌ها
- `get_active_exchanges()`: برای دریافت لیست صرافی‌های فعال
- `get_exchange_by_id()`: برای دریافت صرافی با شناسه
- `get_exchange_by_slug()`: برای دریافت صرافی با slug
- `add_exchange()`: برای افزودن صرافی جدید
- `update_exchange()`: برای به‌روزرسانی اطلاعات صرافی
- `update_exchange_fee()`: برای به‌روزرسانی کارمزد صرافی
- `get_exchange_fees()`: برای دریافت کارمزدهای صرافی

چرا به این سرویس نیاز داریم؟ چون می‌خواهیم عملیات مربوط به صرافی‌ها را در یک نقطه متمرکز کنیم و منطق بیزینسی مربوط به آن را پیاده‌سازی کنیم. مثلاً در متد `get_active_exchanges()` می‌خواهیم فقط صرافی‌های فعال را برگردانیم، یا در متد `update_exchange_fee()` می‌خواهیم کارمزد صرافی را به‌روزرسانی کنیم.

#### سرویس مدیریت قیمت (PriceService)

این سرویس مسئول مدیریت قیمت‌های ارزها است. متدهای اصلی آن عبارتند از:
- `get_latest_prices()`: برای دریافت آخرین قیمت
- `get_latest_prices_by_crypto()`: برای دریافت آخرین قیمت‌ها برای یک ارز
- `update_price()`: برای به‌روزرسانی قیمت
- `get_historical_prices()`: برای دریافت قیمت‌های تاریخی
- `get_price_comparison()`: برای مقایسه قیمت ارز بین صرافی‌های مختلف
- `calculate_average_price()`: برای محاسبه میانگین قیمت ارز بین صرافی‌ها

چرا به این سرویس نیاز داریم؟ چون می‌خواهیم عملیات مربوط به قیمت‌ها را در یک نقطه متمرکز کنیم و منطق بیزینسی مربوط به آن را پیاده‌سازی کنیم. مثلاً در متد `get_price_comparison()` می‌خواهیم قیمت یک ارز را در صرافی‌های مختلف مقایسه کنیم، یا در متد `calculate_average_price()` می‌خواهیم میانگین قیمت یک ارز را بین صرافی‌ها محاسبه کنیم.

#### سرویس تشخیص آربیتراژ (ArbitrageService)

این سرویس مسئول تشخیص فرصت‌های آربیتراژ است. متدهای اصلی آن عبارتند از:
- `detect_opportunities()`: برای تشخیص تمام فرصت‌های آربیتراژ
- `detect_opportunities_for_crypto()`: برای تشخیص فرصت‌های آربیتراژ برای یک ارز
- `get_active_opportunities()`: برای دریافت فرصت‌های فعال
- `get_user_opportunities()`: برای دریافت فرصت‌های منطبق با فیلترهای کاربر
- `close_opportunity()`: برای بستن فرصت آربیتراژ
- `calculate_profit()`: برای محاسبه سود خالص و درصد سود
- `get_opportunity_by_id()`: برای دریافت فرصت با شناسه

چرا به این سرویس نیاز داریم؟ چون می‌خواهیم عملیات مربوط به فرصت‌های آربیتراژ را در یک نقطه متمرکز کنیم و منطق بیزینسی مربوط به آن را پیاده‌سازی کنیم. مثلاً در متد `detect_opportunities()` می‌خواهیم قیمت‌های ارزها را در صرافی‌های مختلف مقایسه کنیم و فرصت‌های آربیتراژ را تشخیص دهیم، یا در متد `get_user_opportunities()` می‌خواهیم فرصت‌های منطبق با فیلترهای کاربر را برگردانیم.

#### سرویس مدیریت اعلان (NotificationService)

این سرویس مسئول مدیریت اعلان‌ها است. متدهای اصلی آن عبارتند از:
- `send_notification()`: برای ارسال اعلان به کاربر
- `send_arbitrage_notification()`: برای ارسال اعلان فرصت آربیتراژ
- `get_user_notifications()`: برای دریافت اعلان‌های کاربر
- `mark_as_read()`: برای علامت‌گذاری اعلان به عنوان خوانده شده
- `get_unread_count()`: برای دریافت تعداد اعلان‌های خوانده نشده
- `should_send_notification()`: برای بررسی مجاز بودن ارسال اعلان
- `retry_failed_notifications()`: برای تلاش مجدد برای ارسال اعلان‌های ناموفق

چرا به این سرویس نیاز داریم؟ چون می‌خواهیم عملیات مربوط به اعلان‌ها را در یک نقطه متمرکز کنیم و منطق بیزینسی مربوط به آن را پیاده‌سازی کنیم. مثلاً در متد `send_arbitrage_notification()` می‌خواهیم اعلان فرصت آربیتراژ را به کاربر ارسال کنیم، یا در متد `should_send_notification()` می‌خواهیم بررسی کنیم که آیا ارسال اعلان به کاربر در این زمان مجاز است.

#### سرویس فیلتر فرصت‌های آربیتراژ (ArbitrageFilterService)

این سرویس مسئول فیلتر کردن فرصت‌های آربیتراژ است. متدهای اصلی آن عبارتند از:
- `get_user_filters()`: برای دریافت فیلترهای کاربر
- `update_user_filters()`: برای به‌روزرسانی فیلترهای کاربر
- `filter_opportunities()`: برای فیلتر کردن فرصت‌ها بر اساس فیلتر
- `is_filter_valid()`: برای بررسی معتبر بودن فیلتر
- `suggest_profit_threshold()`: برای پیشنهاد حد آستانه سود بر اساس تاریخچه کاربر
- `filter_for_free_users()`: برای فیلتر فرصت‌ها برای کاربران رایگان

چرا به این سرویس نیاز داریم؟ چون می‌خواهیم به کاربران امکان دهیم فرصت‌های آربیتراژ را بر اساس معیارهای مختلف فیلتر کنند. مثلاً ممکن است کاربری فقط به فرصت‌های با سود بیش از 5% علاقه‌مند باشد، یا فقط به فرصت‌های مربوط به بیت‌کوین. همچنین می‌خواهیم تعداد فرصت‌هایی که به کاربران رایگان نشان می‌دهیم را محدود کنیم.

## ماژول Content: مدیریت محتوا

ماژول Content مسئول مدیریت محتوای سایت، مقالات، سوالات متداول، راهنمای صرافی‌ها و پیام‌های ارتباط با ما است.

### Entity‌های ماژول Content

#### Entity مقاله (Article)

این Entity اطلاعات مربوط به مقالات سایت را نگهداری می‌کند. فیلدهای اصلی آن عبارتند از:
- اطلاعات پایه: عنوان، نام مستعار (slug)، خلاصه، محتوای کامل، تصویر شاخص
- اطلاعات نویسنده: شناسه نویسنده
- اطلاعات دسته‌بندی: دسته‌بندی، برچسب‌ها
- اطلاعات وضعیت: وضعیت مقاله (پیش‌نویس، منتشر شده، آرشیو شده)
- اطلاعات آمار: تعداد بازدید
- اطلاعات زمانی: تاریخ انتشار
- تنظیمات: ویژه بودن مقاله
- اطلاعات SEO: عنوان SEO، توضیحات متا

متدهای اصلی این Entity عبارتند از:
- `new()`: برای ایجاد مقاله جدید
- `update()`: برای به‌روزرسانی مقاله
- `publish()`: برای انتشار مقاله
- `unpublish()`: برای لغو انتشار مقاله
- `archive()`: برای آرشیو کردن مقاله
- `increment_view_count()`: برای افزایش تعداد بازدید
- `set_featured()`: برای تنظیم وضعیت ویژه بودن
- `is_published()`: برای بررسی منتشر شده بودن

چرا به این Entity نیاز داریم؟ چون می‌خواهیم محتوای آموزشی و اطلاع‌رسانی مرتبط با ارزهای دیجیتال و آربیتراژ را در سایت منتشر کنیم. مقالات می‌توانند به کاربران کمک کنند تا با مفاهیم ارزهای دیجیتال، صرافی‌ها و استراتژی‌های آربیتراژ آشنا شوند.

#### Entity پیام تماس (ContactMessage)

این Entity اطلاعات مربوط به پیام‌های دریافتی از فرم تماس با ما را نگهداری می‌کند. فیلدهای اصلی آن عبارتند از:
- اطلاعات فرستنده: نام، ایمیل، شماره تلفن (اختیاری)
- اطلاعات پیام: موضوع، متن پیام
- ارتباطات: شناسه کاربر (اگر وارد شده باشد)
- اطلاعات وضعیت: وضعیت پیام (جدید، خوانده شده، پاسخ داده شده)
- اطلاعات اضافی: آدرس IP فرستنده
- اطلاعات زمانی: تاریخ ارسال پیام، تاریخ خواندن پیام، تاریخ پاسخ به پیام
- اطلاعات پاسخ: شناسه کاربر خواننده، شناسه کاربر پاسخ دهنده، متن پاسخ

متدهای اصلی این Entity عبارتند از:
- `new()`: برای ایجاد پیام جدید
- `mark_as_read()`: برای علامت‌گذاری به عنوان خوانده شده
- `reply()`: برای ثبت پاسخ به پیام
- `is_replied()`: برای بررسی پاسخ داده شدن
- `is_read()`: برای بررسی خوانده شدن

چرا به این Entity نیاز داریم؟ چون می‌خواهیم به کاربران امکان دهیم با ما در تماس باشند و سوالات، پیشنهادات یا انتقادات خود را مطرح کنند. همچنین می‌خواهیم بتوانیم پیام‌های دریافتی را مدیریت کنیم و به آنها پاسخ دهیم.

#### Entity سوال متداول (Faq)

این Entity اطلاعات مربوط به سوالات متداول سایت را نگهداری می‌کند. فیلدهای اصلی آن عبارتند از:
- اطلاعات پایه: دسته‌بندی، متن سوال، متن پاسخ
- اطلاعات نمایش: ترتیب نمایش
- اطلاعات وضعیت: فعال بودن
- اطلاعات مدیریتی: شناسه ایجادکننده، شناسه آخرین ویرایش‌کننده

متدهای اصلی این Entity عبارتند از:
- `new()`: برای ایجاد سوال متداول جدید
- `update()`: برای به‌روزرسانی سوال متداول
- `activate()`: برای فعال کردن سوال
- `deactivate()`: برای غیرفعال کردن سوال
- `change_order()`: برای تغییر ترتیب نمایش

چرا به این Entity نیاز داریم؟ چون می‌خواهیم به سوالات رایج کاربران پاسخ دهیم بدون اینکه آنها نیاز به تماس با ما داشته باشند. سوالات متداول می‌توانند به کاربران کمک کنند تا سریع‌تر پاسخ سوالات خود را بیابند.

#### Entity راهنمای صرافی (ExchangeGuide)

این Entity اطلاعات مربوط به راهنماهای صرافی‌ها را نگهداری می‌کند. فیلدهای اصلی آن عبارتند از:
- ارتباطات: شناسه صرافی
- اطلاعات پایه: نوع راهنما (ثبت‌نام، احراز هویت، خرید، و غیره)، عنوان، محتوا
- اطلاعات نمایش: ترتیب نمایش
- اطلاعات وضعیت: فعال بودن
- اطلاعات مدیریتی: شناسه ایجادکننده، شناسه آخرین ویرایش‌کننده

متدهای اصلی این Entity عبارتند از:
- `new()`: برای ایجاد راهنمای جدید
- `update()`: برای به‌روزرسانی راهنما
- `activate()`: برای فعال کردن راهنما
- `deactivate()`: برای غیرفعال کردن راهنما
- `change_order()`: برای تغییر ترتیب نمایش

چرا به این Entity نیاز داریم؟ چون می‌خواهیم به کاربران کمک کنیم تا با نحوه استفاده از صرافی‌های مختلف آشنا شوند. راهنماهای گام به گام می‌توانند به کاربران کمک کنند تا راحت‌تر در صرافی‌ها ثبت‌نام کنند، احراز هویت انجام دهند، ارز بخرند و بفروشند و غیره.

### Value Object‌های ماژول Content

#### Value Object وضعیت مقاله (ArticleStatus)

این Value Object، وضعیت یک مقاله را نگهداری می‌کند. مقادیر مجاز آن عبارتند از: `Draft` (پیش‌نویس)، `Published` (منتشر شده)، `Archived` (آرشیو شده). متدهای اصلی آن عبارتند از:
- `is_draft()`: برای بررسی پیش‌نویس بودن
- `is_published()`: برای بررسی منتشر شده بودن
- `is_archived()`: برای بررسی آرشیو شده بودن
- `can_be_changed_to()`: برای بررسی امکان تغییر به وضعیت دیگر
- `display_name()`: برای دریافت نام نمایشی وضعیت

چرا به این Value Object نیاز داریم؟ چون می‌خواهیم وضعیت‌های مختلف مقاله را به صورت استاندارد مدیریت کنیم و قوانین انتقال بین وضعیت‌ها را تعریف کنیم. مثلاً ممکن است نخواهیم مقاله آرشیو شده را مستقیماً به وضعیت منتشر شده برگردانیم.

#### Value Object دسته‌بندی مقاله (ArticleCategory)

این Value Object، دسته‌بندی یک مقاله را نگهداری می‌کند. مقادیر مجاز آن می‌تواند شامل دسته‌بندی‌های مختلف مانند "آموزش"، "اخبار"، "تحلیل" و غیره باشد. متدهای اصلی آن عبارتند از:
- `display_name()`: برای دریافت نام نمایشی دسته‌بندی
- `slug()`: برای دریافت نام مستعار دسته‌بندی برای استفاده در URL
- `description()`: برای دریافت توضیحات دسته‌بندی

چرا به این Value Object نیاز داریم؟ چون می‌خواهیم مقالات را در دسته‌بندی‌های مختلف قرار دهیم تا کاربران راحت‌تر بتوانند به محتوای مورد نظر خود دسترسی داشته باشند. همچنین می‌خواهیم بتوانیم فیلتر و جستجو بر اساس دسته‌بندی را پیاده‌سازی کنیم.

#### Value Object وضعیت پیام (MessageStatus)

این Value Object، وضعیت یک پیام تماس را نگهداری می‌کند. مقادیر مجاز آن عبارتند از: `New` (جدید)، `Read` (خوانده شده)، `Replied` (پاسخ داده شده). متدهای اصلی آن عبارتند از:
- `is_new()`: برای بررسی جدید بودن
- `is_read()`: برای بررسی خوانده شده بودن
- `is_replied()`: برای بررسی پاسخ داده شده بودن
- `can_be_changed_to()`: برای بررسی امکان تغییر به وضعیت دیگر
- `display_name()`: برای دریافت نام نمایشی وضعیت

چرا به این Value Object نیاز داریم؟ چون می‌خواهیم وضعیت‌های مختلف پیام را به صورت استاندارد مدیریت کنیم و قوانین انتقال بین وضعیت‌ها را تعریف کنیم. مثلاً ممکن است بخواهیم فقط پیام‌های خوانده شده را بتوان پاسخ داد.

#### Value Object نوع راهنما (GuideType)

این Value Object، نوع یک راهنمای صرافی را نگهداری می‌کند. مقادیر مجاز آن می‌تواند شامل انواع مختلف راهنما مانند "ثبت‌نام"، "احراز هویت"، "خرید"، "فروش"، "برداشت" و غیره باشد. متدهای اصلی آن عبارتند از:
- `display_name()`: برای دریافت نام نمایشی نوع راهنما
- `description()`: برای دریافت توضیحات نوع راهنما
- `icon()`: برای دریافت آیکون مرتبط با نوع راهنما

چرا به این Value Object نیاز داریم؟ چون می‌خواهیم راهنماهای صرافی را در دسته‌بندی‌های مختلف قرار دهیم تا کاربران راحت‌تر بتوانند به راهنمای مورد نظر خود دسترسی داشته باشند. همچنین می‌خواهیم بتوانیم فیلتر و جستجو بر اساس نوع راهنما را پیاده‌سازی کنیم.

### رویدادهای ماژول Content

#### رویداد انتشار مقاله (ArticlePublished)

این رویداد زمانی منتشر می‌شود که یک مقاله منتشر می‌شود. فیلدهای اصلی آن عبارتند از:
- `article_id`: شناسه مقاله
- `author_id`: شناسه نویسنده
- `title`: عنوان مقاله
- `publish_date`: تاریخ انتشار
- `timestamp`: زمان انتشار رویداد

چرا به این رویداد نیاز داریم؟ چون می‌خواهیم بخش‌های مختلف سیستم را از انتشار مقاله جدید مطلع کنیم. مثلاً ممکن است بخواهیم به کاربرانی که این دسته‌بندی را دنبال می‌کنند اطلاع دهیم، یا مقاله را در صفحه اصلی سایت نمایش دهیم.

#### رویداد به‌روزرسانی مقاله (ArticleUpdated)

این رویداد زمانی منتشر می‌شود که اطلاعات یک مقاله به‌روزرسانی می‌شود. فیلدهای اصلی آن عبارتند از:
- `article_id`: شناسه مقاله
- `editor_id`: شناسه ویرایش‌کننده
- `updated_fields`: فیلدهای به‌روزرسانی شده
- `timestamp`: زمان به‌روزرسانی

چرا به این رویداد نیاز داریم؟ چون می‌خواهیم بخش‌های مختلف سیستم را از تغییرات در مقاله مطلع کنیم. مثلاً ممکن است بخواهیم کش‌های مقاله را بی‌اعتبار کنیم یا به کاربرانی که مقاله را نشان کرده‌اند اطلاع دهیم.

#### رویداد دریافت پیام (MessageReceived)

این رویداد زمانی منتشر می‌شود که یک پیام جدید از طریق فرم تماس دریافت می‌شود. فیلدهای اصلی آن عبارتند از:
- `message_id`: شناسه پیام
- `sender_name`: نام فرستنده
- `sender_email`: ایمیل فرستنده
- `subject`: موضوع پیام
- `timestamp`: زمان دریافت پیام

چرا به این رویداد نیاز داریم؟ چون می‌خواهیم بخش‌های مختلف سیستم را از دریافت پیام جدید مطلع کنیم. مثلاً ممکن است بخواهیم یک ایمیل تأیید به فرستنده ارسال کنیم یا به مدیران سایت اطلاع دهیم.

#### رویداد پاسخ به پیام (MessageReplied)

این رویداد زمانی منتشر می‌شود که به یک پیام تماس پاسخ داده می‌شود. فیلدهای اصلی آن عبارتند از:
- `message_id`: شناسه پیام
- `replier_id`: شناسه پاسخ دهنده
- `reply_content`: محتوای پاسخ
- `timestamp`: زمان پاسخ

چرا به این رویداد نیاز داریم؟ چون می‌خواهیم بخش‌های مختلف سیستم را از پاسخ به پیام مطلع کنیم. مثلاً ممکن است بخواهیم یک ایمیل حاوی پاسخ به فرستنده اصلی پیام ارسال کنیم.

### سرویس‌های ماژول Content

#### سرویس مدیریت مقاله (ArticleService)

این سرویس مسئول مدیریت مقالات است. متدهای اصلی آن عبارتند از:
- `create_article()`: برای ایجاد مقاله جدید
- `update_article()`: برای به‌روزرسانی مقاله
- `publish_article()`: برای انتشار مقاله
- `unpublish_article()`: برای لغو انتشار مقاله
- `archive_article()`: برای آرشیو کردن مقاله
- `get_article_by_id()`: برای دریافت مقاله با شناسه
- `get_article_by_slug()`: برای دریافت مقاله با slug
- `get_articles()`: برای دریافت لیست مقالات
- `get_featured_articles()`: برای دریافت مقالات ویژه

چرا به این سرویس نیاز داریم؟ چون می‌خواهیم عملیات مربوط به مقالات را در یک نقطه متمرکز کنیم و منطق بیزینسی مربوط به آن را پیاده‌سازی کنیم. مثلاً در متد `publish_article()` می‌خواهیم وضعیت مقاله را به "منتشر شده" تغییر دهیم، تاریخ انتشار را ثبت کنیم و رویداد `ArticlePublished` را منتشر کنیم.

#### سرویس مدیریت پیام تماس (ContactService)

این سرویس مسئول مدیریت پیام‌های تماس است. متدهای اصلی آن عبارتند از:
- `submit_message()`: برای ثبت پیام جدید
- `get_message_by_id()`: برای دریافت پیام با شناسه
- `get_messages()`: برای دریافت لیست پیام‌ها
- `mark_as_read()`: برای علامت‌گذاری پیام به عنوان خوانده شده
- `reply_to_message()`: برای ثبت پاسخ به پیام
- `get_unread_count()`: برای دریافت تعداد پیام‌های خوانده نشده
- `send_confirmation_email()`: برای ارسال ایمیل تأییدیه دریافت پیام
- `send_reply_email()`: برای ارسال پاسخ به ایمیل کاربر

چرا به این سرویس نیاز داریم؟ چون می‌خواهیم عملیات مربوط به پیام‌های تماس را در یک نقطه متمرکز کنیم و منطق بیزینسی مربوط به آن را پیاده‌سازی کنیم. مثلاً در متد `submit_message()` می‌خواهیم پیام جدید را ثبت کنیم، رویداد `MessageReceived` را منتشر کنیم و یک ایمیل تأییدیه به فرستنده ارسال کنیم.

#### سرویس مدیریت سوال متداول (FaqService)

این سرویس مسئول مدیریت سوالات متداول است. متدهای اصلی آن عبارتند از:
- `create_faq()`: برای ایجاد سوال متداول جدید
- `update_faq()`: برای به‌روزرسانی سوال متداول
- `delete_faq()`: برای حذف سوال متداول
- `get_faq_by_id()`: برای دریافت سوال با شناسه
- `get_faqs()`: برای دریافت لیست سوالات
- `get_categories()`: برای دریافت دسته‌بندی‌های موجود
- `reorder_faqs()`: برای تغییر ترتیب نمایش سوالات

چرا به این سرویس نیاز داریم؟ چون می‌خواهیم عملیات مربوط به سوالات متداول را در یک نقطه متمرکز کنیم و منطق بیزینسی مربوط به آن را پیاده‌سازی کنیم. مثلاً در متد `get_faqs()` می‌خواهیم لیست سوالات را بر اساس دسته‌بندی و وضعیت فعال بودن فیلتر کنیم.

#### سرویس مدیریت راهنمای صرافی (GuideService)

این سرویس مسئول مدیریت راهنماهای صرافی است. متدهای اصلی آن عبارتند از:
- `create_guide()`: برای ایجاد راهنمای جدید
- `update_guide()`: برای به‌روزرسانی راهنما
- `delete_guide()`: برای حذف راهنما
- `get_guide_by_id()`: برای دریافت راهنما با شناسه
- `get_guides_by_exchange()`: برای دریافت راهنماهای یک صرافی
- `get_guides_by_type()`: برای دریافت راهنماهای یک صرافی با نوع مشخص
- `reorder_guides()`: برای تغییر ترتیب نمایش راهنماها

چرا به این سرویس نیاز داریم؟ چون می‌خواهیم عملیات مربوط به راهنماهای صرافی را در یک نقطه متمرکز کنیم و منطق بیزینسی مربوط به آن را پیاده‌سازی کنیم. مثلاً در متد `get_guides_by_exchange()` می‌خواهیم راهنماهای یک صرافی خاص را برگردانیم تا به کاربران کمک کنیم با آن صرافی کار کنند.

## جمع‌بندی منطق بیزینسی پروژه GapTrade

پروژه GapTrade یک پلتفرم برای تشخیص و اعلان فرصت‌های آربیتراژ بین صرافی‌های ارز دیجیتال است. منطق بیزینسی اصلی این پروژه را می‌توان به سه بخش اصلی تقسیم کرد:

### 1. مدیریت کاربران و اشتراک‌ها (ماژول User)

این بخش مسئول مدیریت کاربران، اشتراک‌ها، پرداخت‌ها و سیستم رفرال است. کاربران می‌توانند در سیستم ثبت‌نام کنند، اشتراک بخرند، کاربران دیگر را به سیستم معرفی کنند و از این طریق کمیسیون دریافت کنند.

نکات کلیدی این بخش:
- پلن‌های اشتراکی مختلف با سطوح دسترسی متفاوت
- سیستم پرداخت برای خرید اشتراک
- سیستم رفرال برای معرفی کاربران و دریافت کمیسیون
- مدیریت حساب کاربری و اطلاعات شخصی
- امکان اتصال به بات تلگرام برای دریافت اعلان‌ها

### 2. تشخیص و اعلان فرصت‌های آربیتراژ (ماژول Arbitrage)

این بخش مسئول دریافت قیمت‌های ارزهای دیجیتال از صرافی‌های مختلف، مقایسه آنها، تشخیص فرصت‌های آربیتراژ و ارسال اعلان به کاربران است.

نکات کلیدی این بخش:
- دریافت و نگهداری قیمت‌های ارزها در صرافی‌های مختلف
- محاسبه سود خالص آربیتراژ با احتساب کارمزدها
- فیلتر کردن فرصت‌ها بر اساس معیارهای کاربر
- ارسال اعلان به کاربران از طریق کانال‌های مختلف (وب، ایمیل، تلگرام)
- آمار و تحلیل فرصت‌های آربیتراژ

### 3. مدیریت محتوا (ماژول Content)

این بخش مسئول مدیریت محتوای آموزشی و اطلاع‌رسانی سایت، راهنماهای صرافی‌ها، سوالات متداول و پیام‌های ارتباط با ما است.

نکات کلیدی این بخش:
- مقالات آموزشی و اطلاع‌رسانی درباره ارزهای دیجیتال و آربیتراژ
- راهنماهای استفاده از صرافی‌ها (ثبت‌نام، احراز هویت، خرید و فروش)
- سوالات متداول کاربران
- سیستم ارتباط با ما برای دریافت و پاسخ به پیام‌های کاربران

ارتباط بین این سه بخش از طریق رویدادها و سرویس‌های مشترک برقرار می‌شود. مثلاً وقتی کاربر اشتراک می‌خرد (ماژول User)، سیستم بررسی می‌کند که آیا این کاربر از طریق سیستم رفرال معرفی شده است، و اگر چنین است، کمیسیون مربوطه را به کاربر معرف اختصاص می‌دهد. همچنین سطح دسترسی کاربر به فرصت‌های آربیتراژ (ماژول Arbitrage) بر اساس نوع اشتراک او تعیین می‌شود.

به این ترتیب، منطق بیزینسی پروژه GapTrade به صورت ماژولار و با استفاده از اصول معماری تمیز (Clean Architecture) طراحی شده است. این طراحی به ما امکان می‌دهد هر بخش را به صورت مستقل توسعه و آزمایش کنیم، و در عین حال ارتباط منطقی بین بخش‌ها را حفظ کنیم.